<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Diplomat Run</title>
  <style>
    html, body { margin:0; height:100%; background:#121212; font-family: system-ui, -apple-system, "Segoe UI", sans-serif; }
    #wrap { display:flex; justify-content:center; align-items:center; height:100%; }
    canvas { background:#0b0f14; border:1px solid #2a2f38; }
    .hint {
      position: fixed; left: 12px; bottom: 12px; color: #cbd5e1; font-size: 12px; opacity: 0.9;
      background: rgba(0,0,0,0.35); padding: 8px 10px; border: 1px solid rgba(255,255,255,0.08); border-radius: 10px;
      max-width: 520px;
    }
    .hint b { color:#e2e8f0; }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="960" height="540"></canvas>
</div>

<div class="hint">
  <b>操作</b>：←→/AD 移動　Space/W/↑ ジャンプ（空中で再入力：<b>２段ジャンプ</b>）　<b>E 長押し</b> 交渉　Shift ダッシュ　R リトライ<br>
  <b>勝ち方</b>：敵を倒すのではなく「交渉して通す」。交渉失敗は警戒を上げる（難化）。
</div>

<script>
(() => {
  "use strict";

  // =========================================================
  // Core config
  // =========================================================
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const W = canvas.width, H = canvas.height;
  const TILE = 36;
  const GRAVITY = 0.75;
  const MAX_FALL = 18;

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;

  // =========================================================
  // Input
  // =========================================================
  const keys = new Map();
  const justPressed = new Set();
  window.addEventListener("keydown", (e) => {
    if (!keys.get(e.key)) justPressed.add(e.key);
    keys.set(e.key, true);
    // Prevent page scroll on arrows/space
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
  }, { passive:false });

  window.addEventListener("keyup", (e) => {
    keys.set(e.key, false);
  });

  const isDown = (k) => !!keys.get(k);
  const pressed = (k) => justPressed.has(k);

  // =========================================================
  // World / Story data
  // =========================================================
  const STAGES = [
    {
      id: "desert",
      title: "砂漠：境界線の取引",
      palette: { sky:"#1a2330", far:"#1b2b3c", mid:"#2b3a47", ground:"#9a7b4f", accent:"#d7c08c" },
      intro: [
        "中立監察団の交渉官・相良ユウ。",
        "資源輸送路で外交官襲撃が発生。現場は民兵と企業警備が緊張状態。",
        "あなたの任務は『銃を抜かずに通過し、報告書を首都へ届けること』。"
      ],
      // Tiles: 0 empty, 1 solid, 2 hazard (spike/poison), 3 goal
      map: makeStageMap_Desert(),
      enemySpawns: [
        { x: 22*TILE, y: 8*TILE, type:"militia" },
        { x: 44*TILE, y: 8*TILE, type:"militia" },
        { x: 63*TILE, y: 7*TILE, type:"caravan" }, // negotiable "transport leader"
        { x: 88*TILE, y: 8*TILE, type:"militia" },
      ],
      npcNotes: [
        "民兵は『誇りと恐れ』で動く。正論だけでは折れない。",
        "輸送隊は『体面』と『安全』を重視。交渉が通れば全体が沈静化する。"
      ],
    },
    {
      id: "jungle",
      title: "熱帯雨林：見えない戦争",
      palette: { sky:"#0d1b16", far:"#0f261c", mid:"#173528", ground:"#2f5a43", accent:"#9fd3b3" },
      intro: [
        "砂漠の輸送路の背後で、密猟と武器取引がつながっていた。",
        "次の現場は熱帯雨林。視界が悪く、敵味方の境界が曖昧。",
        "交渉は『正しさ』ではなく『出口の設計』だ。"
      ],
      map: makeStageMap_Jungle(),
      enemySpawns: [
        { x: 18*TILE, y: 7*TILE, type:"poacher" },
        { x: 37*TILE, y: 6*TILE, type:"poacher" },
        { x: 55*TILE, y: 7*TILE, type:"guerrilla" }, // hard negotiable
        { x: 73*TILE, y: 7*TILE, type:"poacher" },
      ],
      npcNotes: [
        "密猟者は金で動く。『逮捕』より『撤退条件』が効く。",
        "ゲリラは理念で動く。交渉には『損失を小さく見せる』設計が必要。"
      ],
    },
    {
      id: "city",
      title: "都市：世論と監視",
      palette: { sky:"#10131a", far:"#131722", mid:"#1a2030", ground:"#313847", accent:"#c9d3ff" },
      intro: [
        "襲撃事件は『外』の敵だけではない。首都の政治が火種を育てていた。",
        "都市では監視と世論が武器になる。正義はときに暴力より鋭い。",
        "最後の門は検問。あなたは『正統性』を提示できるか。"
      ],
      map: makeStageMap_City(),
      enemySpawns: [
        { x: 20*TILE, y: 8*TILE, type:"riot" },
        { x: 40*TILE, y: 8*TILE, type:"security" }, // very hard negotiable
        { x: 58*TILE, y: 8*TILE, type:"drone" },    // non-negotiable
        { x: 76*TILE, y: 8*TILE, type:"security" },
      ],
      npcNotes: [
        "治安部隊は『命令』で動く。交渉は『面子』『手続き』の提示が必要。",
        "ドローンは交渉不可。ルート設計（回避）が答えになる。"
      ],
    }
  ];

  function makeStageMap_Desert() {
    // 0 empty, 1 solid ground, 2 hazard, 3 goal
    // height: 15 tiles; width: 110 tiles
    const h = 15, w = 110;
    const m = Array.from({length:h}, () => Array(w).fill(0));

    // baseline ground with pits
    for (let x=0; x<w; x++) {
      // pits (落とし穴)
      const isPit =
        (x>=14 && x<=17) ||
        (x>=31 && x<=33) ||
        (x>=49 && x<=52) ||
        (x>=70 && x<=72) ||
        (x>=97 && x<=99);
      if (!isPit) m[12][x] = 1;
      // some deeper support layer
      if (!isPit) m[13][x] = 1;
      if (!isPit) m[14][x] = 1;
    }

    // platforms / dunes
    rect(m, 10, 8, 6, 1); // small platform
    rect(m, 26, 9, 5, 1);
    rect(m, 40, 8, 7, 1);
    rect(m, 58, 7, 6, 1);
    rect(m, 66, 9, 4, 1);
    rect(m, 82, 8, 6, 1);
    rect(m, 90, 7, 5, 1);

    // hazards: "流砂" = hazard strip (touch = trust drain)
    // represent as 2 on ground surface
    for (let x=34; x<=38; x++) m[11][x] = 2;
    for (let x=73; x<=78; x++) m[11][x] = 2;

    // goal
    m[11][107] = 3;
    m[10][107] = 3;
    return m;
  }

  function makeStageMap_Jungle() {
    const h = 15, w = 95;
    const m = Array.from({length:h}, () => Array(w).fill(0));

    // ground with irregular pits + "poison swamp" hazards
    for (let x=0; x<w; x++) {
      const isPit =
        (x>=10 && x<=12) ||
        (x>=24 && x<=26) ||
        (x>=45 && x<=46) ||
        (x>=60 && x<=63) ||
        (x>=84 && x<=85);
      if (!isPit) {
        m[12][x] = 1; m[13][x] = 1; m[14][x] = 1;
      }
    }

    // vines / platforms
    rect(m, 16, 8, 6, 1);
    rect(m, 32, 7, 7, 1);
    rect(m, 48, 8, 6, 1);
    rect(m, 67, 7, 6, 1);
    rect(m, 78, 8, 5, 1);

    // "朽ち床" (breakable): encode as 4 (we handle separately)
    for (let x=34; x<=37; x++) m[6][x] = 4;

    // poison swamp zones
    for (let x=27; x<=31; x++) m[11][x] = 2;
    for (let x=52; x<=56; x++) m[11][x] = 2;

    // goal
    m[11][92] = 3; m[10][92] = 3;
    return m;
  }

  function makeStageMap_City() {
    const h = 15, w = 90;
    const m = Array.from({length:h}, () => Array(w).fill(0));

    // ground with pits (construction gaps)
    for (let x=0; x<w; x++) {
      const isPit =
        (x>=12 && x<=13) ||
        (x>=29 && x<=31) ||
        (x>=50 && x<=51) ||
        (x>=66 && x<=68);
      if (!isPit) { m[12][x]=1; m[13][x]=1; m[14][x]=1; }
    }

    // elevated sidewalks / rooftops
    rect(m, 18, 9, 8, 1);
    rect(m, 36, 8, 7, 1);
    rect(m, 55, 9, 8, 1);
    rect(m, 73, 8, 6, 1);

    // "監視ゾーン" hazards (spotlight) - stepping triggers trust drain / alert
    for (let x=41; x<=46; x++) m[11][x] = 2;

    // goal: gate
    m[11][87] = 3; m[10][87] = 3;
    return m;
  }

  function rect(map, x, y, w, v) {
    for (let i=0;i<w;i++) map[y][x+i]=v;
  }

  // =========================================================
  // Entities
  // =========================================================
  const game = {
    stageIndex: 0,
    stage: null,
    map: null,
    mapW: 0,
    mapH: 0,
    cameraX: 0,
    cameraY: 0,
    time: 0,
    state: "intro", // intro | play | clear | gameover
    introLine: 0,
    alert: 0, // 0..3 affects enemies
    message: "",
    messageT: 0,
  };

  const player = {
    x: 2*TILE,
    y: 6*TILE,
    w: 26,
    h: 40,
    vx: 0,
    vy: 0,
    onGround: false,
    face: 1,
    trust: 100, // 0..100
    hp: 3,
    dashT: 0,
    dashCD: 0,
    negotiating: null, // enemy ref when negotiating
    negoProgress: 0,
    canDoubleJump: true, // double jump ability flag
  };

  function enemyTemplate(type) {
    // negotiable: true/false; difficulty affects required time; hostility affects contact damage
    const base = {
      type,
      x: 0, y: 0, w: 28, h: 36,
      vx: 0.8, vy: 0,
      dir: -1,
      patrol: 80,
      originX: 0,
      hostile: true,
      negotiable: true,
      difficulty: 1.0,  // higher = slower progress / more failure chance
      stance: "hostile", // hostile | neutral | allied
      aggroRange: 160,
      contactDamage: 1,
      talkText: "",
    };

    if (type === "militia") {
      return { ...base,
        vx: 0.9, patrol: 120, difficulty: 1.1, aggroRange: 170,
        talkText: "民兵：『通行は許可制だ。理由を言え』"
      };
    }
    if (type === "caravan") {
      return { ...base,
        vx: 0.6, patrol: 70, hostile: false, stance: "neutral",
        difficulty: 0.9, aggroRange: 120,
        talkText: "輸送隊：『安全保証があるなら通す。書類は？』"
      };
    }
    if (type === "poacher") {
      return { ...base,
        vx: 1.0, patrol: 110, difficulty: 1.0, aggroRange: 170,
        talkText: "密猟者：『金か、見逃しか。どっちだ』"
      };
    }
    if (type === "guerrilla") {
      return { ...base,
        vx: 1.1, patrol: 140, difficulty: 1.6, aggroRange: 210,
        talkText: "ゲリラ：『正義を語るな。代案を出せ』"
      };
    }
    if (type === "riot") {
      return { ...base,
        vx: 0.8, patrol: 150, difficulty: 1.2, aggroRange: 190,
        talkText: "群衆：『真実を隠してるのか？』"
      };
    }
    if (type === "security") {
      return { ...base,
        vx: 0.95, patrol: 170, difficulty: 1.9, aggroRange: 240,
        talkText: "治安：『許可番号を提示しろ。ないなら引き返せ』"
      };
    }
    if (type === "drone") {
      return { ...base,
        vx: 1.3, patrol: 220, negotiable: false, difficulty: 999,
        aggroRange: 260, talkText: "ドローン：交渉不可（回避せよ）"
      };
    }
    return base;
  }

  let enemies = [];
  let breakTiles = new Map(); // key "x,y" -> remaining durability

  function loadStage(idx) {
    game.stageIndex = idx;
    game.stage = STAGES[idx];
    game.map = game.stage.map;
    game.mapH = game.map.length;
    game.mapW = game.map[0].length;
    game.cameraX = 0; game.cameraY = 0;
    game.time = 0;
    game.state = "intro";
    game.introLine = 0;
    game.alert = 0;
    game.message = "";
    game.messageT = 0;

    // reset player
    player.x = 2*TILE; player.y = 6*TILE;
    player.vx = 0; player.vy = 0;
    player.onGround = false; player.face = 1;
    player.trust = 100;
    player.hp = 3;
    player.dashT = 0;
    player.dashCD = 0;
    player.negotiating = null;
    player.negoProgress = 0;
    player.canDoubleJump = true; // reset double jump ability

    // enemies
    enemies = [];
    for (const s of game.stage.enemySpawns) {
      const e = enemyTemplate(s.type);
      e.x = s.x; e.y = s.y;
      e.originX = e.x;
      enemies.push(e);
    }

    // breakable tiles
    breakTiles.clear();
    for (let y=0; y<game.mapH; y++) {
      for (let x=0; x<game.mapW; x++) {
        if (game.map[y][x] === 4) breakTiles.set(`${x},${y}`, 120); // durability frames
      }
    }
  }

  loadStage(0);

  // =========================================================
  // Tile helpers
  // =========================================================
  function tileAt(tx, ty) {
    if (ty < 0 || ty >= game.mapH || tx < 0 || tx >= game.mapW) return 0;
    return game.map[ty][tx];
  }

  function isSolidTile(v) { return v === 1 || v === 4; } // 4=breakable considered solid until broken
  function isHazardTile(v) { return v === 2; }
  function isGoalTile(v) { return v === 3; }

  function worldToTile(x, y) {
    return { tx: Math.floor(x / TILE), ty: Math.floor(y / TILE) };
  }

  function aabb(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function resolveCollisions(ent) {
    // Move X then resolve
    ent.x += ent.vx;
    let left = Math.floor(ent.x / TILE);
    let right = Math.floor((ent.x + ent.w) / TILE);
    let top = Math.floor(ent.y / TILE);
    let bottom = Math.floor((ent.y + ent.h - 1) / TILE);

    for (let ty = top; ty <= bottom; ty++) {
      for (let tx = left; tx <= right; tx++) {
        const t = tileAt(tx, ty);
        if (!isSolidTile(t)) continue;

        const tileX = tx * TILE, tileY = ty * TILE;
        if (aabb(ent.x, ent.y, ent.w, ent.h, tileX, tileY, TILE, TILE)) {
          if (ent.vx > 0) ent.x = tileX - ent.w;
          else if (ent.vx < 0) ent.x = tileX + TILE;
          ent.vx = 0;
        }
      }
    }

    // Move Y then resolve
    ent.y += ent.vy;
    ent.onGround = false;
    left = Math.floor(ent.x / TILE);
    right = Math.floor((ent.x + ent.w) / TILE);
    top = Math.floor(ent.y / TILE);
    bottom = Math.floor((ent.y + ent.h) / TILE);

    for (let ty = top; ty <= bottom; ty++) {
      for (let tx = left; tx <= right; tx++) {
        const t = tileAt(tx, ty);
        if (!isSolidTile(t)) continue;

        const tileX = tx * TILE, tileY = ty * TILE;
        if (aabb(ent.x, ent.y, ent.w, ent.h, tileX, tileY, TILE, TILE)) {
          if (ent.vy > 0) {
            ent.y = tileY - ent.h;
            ent.vy = 0;
            ent.onGround = true;
          } else if (ent.vy < 0) {
            ent.y = tileY + TILE;
            ent.vy = 0;
          }
        }
      }
    }
  }

  function hazardTouch(ent) {
    // sample feet area
    const p1 = worldToTile(ent.x + 4, ent.y + ent.h);
    const p2 = worldToTile(ent.x + ent.w - 4, ent.y + ent.h);
    const t1 = tileAt(p1.tx, p1.ty);
    const t2 = tileAt(p2.tx, p2.ty);
    return isHazardTile(t1) || isHazardTile(t2);
  }

  function goalTouch(ent) {
    const p1 = worldToTile(ent.x + 4, ent.y + ent.h - 4);
    const p2 = worldToTile(ent.x + ent.w - 4, ent.y + ent.h - 4);
    const t1 = tileAt(p1.tx, p1.ty);
    const t2 = tileAt(p2.tx, p2.ty);
    return isGoalTile(t1) || isGoalTile(t2);
  }

  // =========================================================
  // Negotiation system
  // =========================================================
  function nearestNegotiableEnemy() {
    let best = null;
    let bestD = 999999;
    for (const e of enemies) {
      if (e.stance === "allied") continue;
      if (!e.negotiable) continue;
      const dx = (e.x + e.w/2) - (player.x + player.w/2);
      const dy = (e.y + e.h/2) - (player.y + player.h/2);
      const d = Math.hypot(dx, dy);
      if (d < 78 && d < bestD) { bestD = d; best = e; }
    }
    return best;
  }

  function startNegotiation(e) {
    player.negotiating = e;
    player.negoProgress = 0;
    say(e.talkText, 140);
  }

  function stopNegotiation() {
    player.negotiating = null;
    player.negoProgress = 0;
  }

  function negotiationTick() {
    const e = player.negotiating;
    if (!e) return;

    // If too far, cancel
    const dx = Math.abs((e.x+e.w/2) - (player.x+player.w/2));
    const dy = Math.abs((e.y+e.h/2) - (player.y+player.h/2));
    if (dx > 90 || dy > 70) {
      say("交渉が途切れた。距離を詰めろ。", 110);
      stopNegotiation();
      return;
    }

    // If player attacked or in hazard, cancel
    if (hazardTouch(player)) {
      say("足元が不安定だ。安全を確保して交渉しろ。", 110);
      stopNegotiation();
      return;
    }

    // Progress speed affected by alert + difficulty
    const alertPenalty = 1 + game.alert * 0.35;
    const speed = 0.9 / (e.difficulty * alertPenalty);

    player.negoProgress += speed;

    // Chance of failure increases with alert and difficulty
    const failChance = 0.0008 * e.difficulty * (1 + game.alert * 0.6);
    if (Math.random() < failChance) {
      // fail
      game.alert = clamp(game.alert + 1, 0, 3);
      player.trust = clamp(player.trust - 10, 0, 100);
      say("交渉失敗。警戒が上がった。", 160);
      stopNegotiation();
      return;
    }

    if (player.negoProgress >= 100) {
      // success: some become allied (info), others simply stand down
      if (e.type === "caravan") {
        e.stance = "allied";
        e.hostile = false;
        say("成功：輸送隊が通行を保証した（警戒 -1）", 180);
        game.alert = clamp(game.alert - 1, 0, 3);
      } else if (e.type === "guerrilla") {
        e.stance = "allied";
        e.hostile = false;
        say("成功：ゲリラが撤退路を提示した（情報：近道がある）", 180);
        // Give player a trust boost as narrative payoff
        player.trust = clamp(player.trust + 8, 0, 100);
      } else if (e.type === "security") {
        e.stance = "neutral";
        e.hostile = false;
        say("成功：手続きが通った。治安部隊は通過を黙認。", 180);
        player.trust = clamp(player.trust + 5, 0, 100);
      } else {
        e.stance = "neutral";
        e.hostile = false;
        say("成功：相手は退いた。『通れ』", 160);
      }
      stopNegotiation();
    }
  }

  // =========================================================
  // Messaging / UI
  // =========================================================
  function say(msg, t=140) {
    game.message = msg;
    game.messageT = t;
  }

  // =========================================================
  // Game loop
  // =========================================================
  function update() {
    game.time++;

    if (game.messageT > 0) game.messageT--;

    if (game.state === "intro") {
      // Advance intro with Enter or E or Space
      if (pressed("Enter") || pressed(" ") || pressed("e") || pressed("E")) {
        game.introLine++;
        if (game.introLine >= game.stage.intro.length) {
          game.state = "play";
          say("任務開始：壊さずに通れ。", 150);
        }
      }
      return;
    }

    if (game.state === "gameover") {
      if (pressed("r") || pressed("R")) loadStage(game.stageIndex);
      return;
    }

    if (game.state === "clear") {
      if (game.stageIndex < STAGES.length - 1) {
        loadStage(game.stageIndex + 1);
      } else {
        // end
        game.state = "intro";
        game.stage = {
          title: "完了：報告書は届いた",
          palette: { sky:"#0b1020", far:"#0b1020", mid:"#0b1020", ground:"#0b1020", accent:"#e2e8f0" },
          intro: [
            "あなたは最後の検問を越えた。",
            "報告書は首都に届き、襲撃の構造は露呈する。",
            "黒幕は一人ではない。だが、壊さずに通す道は確かに存在した。",
            "もう一度遊ぶなら R。"
          ],
          map: Array.from({length:15}, () => Array(40).fill(0)),
          enemySpawns: [],
          npcNotes: []
        };
        game.map = game.stage.map;
        game.mapH = game.map.length;
        game.mapW = game.map[0].length;
        game.introLine = 0;
        enemies = [];
      }
      return;
    }

    // =====================================================
    // PLAY state
    // =====================================================
    // Player control
    const left = isDown("ArrowLeft") || isDown("a") || isDown("A");
    const right = isDown("ArrowRight") || isDown("d") || isDown("D");
    const jump = pressed(" ") || pressed("ArrowUp") || pressed("w") || pressed("W");
    const dash = pressed("Shift");

    // dash
    if (player.dashCD > 0) player.dashCD--;
    if (player.dashT > 0) player.dashT--;

    if (dash && player.dashCD === 0) {
      player.dashT = 14;
      player.dashCD = 65;
      say("ダッシュ", 30);
    }

    const moveSpeed = player.dashT > 0 ? 6.2 : 3.2;

    if (left && !right) { player.vx = -moveSpeed; player.face = -1; }
    else if (right && !left) { player.vx = moveSpeed; player.face = 1; }
    else player.vx = lerp(player.vx, 0, 0.4);

    // Jump and Double Jump logic
    if (jump) {
      if (player.onGround) {
        // First jump from ground
        player.vy = -13.2;
        player.onGround = false;
        player.canDoubleJump = true; // reset double jump when jumping from ground
      } else if (player.canDoubleJump) {
        // Double jump in air
        player.vy = -12.0; // slightly weaker than first jump
        player.canDoubleJump = false;
      }
    }

    // Reset double jump ability when landing
    if (player.onGround) {
      player.canDoubleJump = true;
    }

    // gravity
    player.vy = clamp(player.vy + GRAVITY, -999, MAX_FALL);

    // negotiation start/hold
    const eNear = nearestNegotiableEnemy();
    const eKeyHeld = isDown("e") || isDown("E");
    if (eKeyHeld) {
      if (!player.negotiating && eNear) startNegotiation(eNear);
      if (player.negotiating) negotiationTick();
    } else {
      if (player.negotiating) stopNegotiation();
    }

    // apply movement/collision
    resolveCollisions(player);

    // hazards: trust drains; falling pits: if y > map bottom -> death
    if (hazardTouch(player)) {
      player.trust = clamp(player.trust - 0.35, 0, 100);
      // In city hazard also raises alert slowly
      if (game.stage.id === "city" && Math.random() < 0.03) {
        game.alert = clamp(game.alert + 1, 0, 3);
        say("監視が反応した。警戒 +1", 90);
      }
    }

    // breakable tiles: standing on them decreases durability
    updateBreakablesUnderPlayer();

    // goal
    if (goalTouch(player)) {
      game.state = "clear";
      say("通過成功：次の現場へ", 120);
    }

    // enemy updates and interactions
    updateEnemies();

    // fail conditions
    if (player.y > game.mapH*TILE + 220) {
      // fell into pit
      player.hp = 0;
      die("落下：落とし穴に落ちた。");
    }
    if (player.trust <= 0) {
      die("信頼が尽きた：現場はあなたを拒絶した。");
    }
    if (player.hp <= 0) {
      die("負傷：任務続行不能。");
    }

    // camera
    const targetX = clamp(player.x - W*0.45, 0, game.mapW*TILE - W);
    game.cameraX = lerp(game.cameraX, targetX, 0.12);
    game.cameraY = 0;
  }

  function updateBreakablesUnderPlayer() {
    // Check tiles just beneath player's feet
    const footY = player.y + player.h + 1;
    const leftX = player.x + 4;
    const rightX = player.x + player.w - 4;

    const a = worldToTile(leftX, footY);
    const b = worldToTile(rightX, footY);

    for (const p of [a,b]) {
      if (tileAt(p.tx, p.ty) === 4) {
        const key = `${p.tx},${p.ty}`;
        const d = breakTiles.get(key) ?? 0;
        const nd = d - 1;
        breakTiles.set(key, nd);
        if (nd === 60) say("床が軋む…", 60);
        if (nd <= 0) {
          // break: set to empty
          game.map[p.ty][p.tx] = 0;
          say("床が崩れた。", 80);
        }
      }
    }
  }

  function updateEnemies() {
    const alertMul = 1 + game.alert * 0.22;

    for (const e of enemies) {
      // drones hover: ignore ground a bit
      if (e.type === "drone") {
        e.y += Math.sin(game.time * 0.06) * 0.45;
      }

      // allied/neutral don't attack
      const canAttack = e.hostile && e.stance !== "allied";

      // patrol
      const patrolLeft = e.originX - e.patrol;
      const patrolRight = e.originX + e.patrol;

      // aggro movement toward player if close and hostile
      const dx = (player.x + player.w/2) - (e.x + e.w/2);
      const dist = Math.abs(dx);

      let speed = e.vx * alertMul;
      if (e.stance === "neutral") speed *= 0.6;

      if (canAttack && dist < e.aggroRange) {
        e.dir = dx >= 0 ? 1 : -1;
        e.vx = e.dir * speed;
      } else {
        // normal patrol
        e.vx = e.dir * speed * 0.85;
        if (e.x < patrolLeft) e.dir = 1;
        if (e.x > patrolRight) e.dir = -1;
      }

      // gravity for non-drones
      if (e.type !== "drone") {
        e.vy = clamp(e.vy + GRAVITY, -999, MAX_FALL);
      } else {
        e.vy = 0;
      }

      resolveCollisions(e);

      // contact damage if hostile
      if (canAttack && aabb(player.x, player.y, player.w, player.h, e.x, e.y, e.w, e.h)) {
        // If negotiating, break it
        if (player.negotiating) stopNegotiation();
        // damage
        player.hp -= e.contactDamage;
        player.trust = clamp(player.trust - 7, 0, 100);
        say("接触：押し返された（HP -1 / 信頼 -7）", 120);
        // knockback
        player.vx = -e.dir * 5.2;
        player.vy = -7.5;
        // alert rises on clash
        game.alert = clamp(game.alert + 1, 0, 3);
      }
    }
  }

  function die(reason) {
    game.state = "gameover";
    say(reason + "　Rで再開。", 999999);
  }

  // =========================================================
  // Rendering
  // =========================================================
  function draw() {
    const pal = game.stage.palette || { sky:"#0b0f14", far:"#0b0f14", mid:"#0b0f14", ground:"#222", accent:"#fff" };

    // background
    ctx.fillStyle = pal.sky;
    ctx.fillRect(0,0,W,H);

    // parallax layers
    const px = game.cameraX;
    drawParallax(pal.far, 0.15, 34);
    drawParallax(pal.mid, 0.30, 22);

    // world
    ctx.save();
    ctx.translate(-Math.floor(game.cameraX), -Math.floor(game.cameraY));

    drawTiles(pal);
    drawEnemies(pal);
    drawPlayer(pal);

    ctx.restore();

    // HUD
    drawHUD(pal);

    // Intro overlay
    if (game.state === "intro") drawIntroOverlay(pal);

    // Gameover overlay
    if (game.state === "gameover") drawGameoverOverlay(pal);
  }

  function drawParallax(color, factor, height) {
    ctx.fillStyle = color;
    const offset = -(game.cameraX * factor) % W;
    for (let i=-1;i<=1;i++) {
      ctx.fillRect(offset + i*W, H - height - 110, W, height);
    }
  }

  function drawTiles(pal) {
    const startX = Math.floor(game.cameraX / TILE) - 2;
    const endX = Math.floor((game.cameraX + W) / TILE) + 2;
    const startY = 0;
    const endY = game.mapH;

    for (let ty=startY; ty<endY; ty++) {
      for (let tx=startX; tx<=endX; tx++) {
        const t = tileAt(tx, ty);
        if (t === 0) continue;

        const x = tx*TILE, y = ty*TILE;

        if (t === 1) {
          ctx.fillStyle = pal.ground;
          ctx.fillRect(x, y, TILE, TILE);
        } else if (t === 2) {
          // hazard
          ctx.fillStyle = "#7c2d12";
          ctx.fillRect(x, y, TILE, TILE);
          ctx.fillStyle = "rgba(255,255,255,0.20)";
          ctx.fillRect(x+6, y+6, TILE-12, TILE-12);
        } else if (t === 3) {
          // goal gate
          ctx.fillStyle = pal.accent;
          ctx.fillRect(x, y, TILE, TILE);
          ctx.fillStyle = "rgba(0,0,0,0.35)";
          ctx.fillRect(x+8, y+8, TILE-16, TILE-16);
        } else if (t === 4) {
          // breakable
          const key = `${tx},${ty}`;
          const d = breakTiles.get(key) ?? 120;
          const a = clamp(d/120, 0, 1);
          ctx.fillStyle = `rgba(140, 180, 160, ${0.25 + 0.55*a})`;
          ctx.fillRect(x, y, TILE, TILE);
          ctx.fillStyle = "rgba(0,0,0,0.25)";
          ctx.fillRect(x+10, y+10, TILE-20, TILE-20);
        }
      }
    }
  }

  function drawPlayer(pal) {
    const px = player.x;
    const py = player.y;
    const pw = player.w;
    const ph = player.h;
    const facing = player.face; // 1 = right, -1 = left

    // === Legs (dark suit pants) ===
    ctx.fillStyle = "#1e293b"; // dark navy pants
    const legWidth = 8;
    const legHeight = 14;
    const legY = py + ph - legHeight;
    // Left leg
    ctx.fillRect(px + 4, legY, legWidth, legHeight);
    // Right leg
    ctx.fillRect(px + pw - 12, legY, legWidth, legHeight);
    // Shoes
    ctx.fillStyle = "#0f172a"; // black shoes
    ctx.fillRect(px + 3, py + ph - 4, legWidth + 2, 4);
    ctx.fillRect(px + pw - 13, py + ph - 4, legWidth + 2, 4);

    // === Suit jacket (torso) ===
    const jacketY = py + 16;
    const jacketH = ph - 16 - legHeight;
    ctx.fillStyle = "#1e3a5f"; // dark blue suit jacket
    ctx.fillRect(px + 2, jacketY, pw - 4, jacketH);
    // Jacket lapels (V-shape collar)
    ctx.fillStyle = "#0f2942"; // darker lapel
    ctx.beginPath();
    ctx.moveTo(px + pw / 2, jacketY);
    ctx.lineTo(px + 4, jacketY + 8);
    ctx.lineTo(px + 4, jacketY);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(px + pw / 2, jacketY);
    ctx.lineTo(px + pw - 4, jacketY + 8);
    ctx.lineTo(px + pw - 4, jacketY);
    ctx.closePath();
    ctx.fill();
    // Suit buttons
    ctx.fillStyle = "#d4af37"; // gold buttons
    ctx.beginPath();
    ctx.arc(px + pw / 2, jacketY + 10, 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(px + pw / 2, jacketY + 18, 2, 0, Math.PI * 2);
    ctx.fill();

    // === White dress shirt (visible under jacket) ===
    ctx.fillStyle = "#f8fafc"; // white shirt
    ctx.fillRect(px + pw / 2 - 4, jacketY, 8, 10);

    // === Tie ===
    ctx.fillStyle = "#dc2626"; // red tie
    const tieX = px + pw / 2 - 3;
    ctx.fillRect(tieX, jacketY + 2, 6, 16);
    // Tie knot
    ctx.fillStyle = "#b91c1c";
    ctx.fillRect(tieX + 1, jacketY + 1, 4, 4);

    // === Head ===
    const headY = py;
    const headH = 16;
    // Face / skin
    ctx.fillStyle = "#fcd9b6"; // skin tone
    ctx.fillRect(px + 5, headY + 4, pw - 10, headH - 4);
    // Hair
    ctx.fillStyle = "#1c1917"; // dark hair
    ctx.fillRect(px + 4, headY, pw - 8, 6);
    if (facing === 1) {
      ctx.fillRect(px + 4, headY, 4, 10); // side hair left
    } else {
      ctx.fillRect(px + pw - 8, headY, 4, 10); // side hair right
    }
    // Eyes
    ctx.fillStyle = "#0f172a";
    if (facing === 1) {
      ctx.fillRect(px + pw - 12, headY + 8, 3, 3);
    } else {
      ctx.fillRect(px + 9, headY + 8, 3, 3);
    }

    // === Arms (suit sleeves) ===
    ctx.fillStyle = "#1e3a5f"; // same as jacket
    const armY = jacketY + 4;
    const armH = 12;
    if (facing === 1) {
      // Right arm forward
      ctx.fillRect(px + pw - 2, armY, 6, armH);
      // Hand
      ctx.fillStyle = "#fcd9b6";
      ctx.fillRect(px + pw - 1, armY + armH, 4, 5);
    } else {
      // Left arm forward
      ctx.fillRect(px - 4, armY, 6, armH);
      // Hand
      ctx.fillStyle = "#fcd9b6";
      ctx.fillRect(px - 3, armY + armH, 4, 5);
    }

    // === Briefcase (diplomat accessory) ===
    ctx.fillStyle = "#78350f"; // brown briefcase
    const briefcaseY = armY + armH + 5;
    if (facing === 1) {
      ctx.fillRect(px + pw, briefcaseY, 10, 8);
      ctx.fillStyle = "#d4af37"; // gold clasp
      ctx.fillRect(px + pw + 3, briefcaseY + 2, 4, 2);
    } else {
      ctx.fillRect(px - 10, briefcaseY, 10, 8);
      ctx.fillStyle = "#d4af37";
      ctx.fillRect(px - 7, briefcaseY + 2, 4, 2);
    }

    // === Negotiation indicator ===
    const eNear = nearestNegotiableEnemy();
    if (game.state === "play" && eNear && !player.negotiating) {
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, sans-serif";
      ctx.fillText("E:交渉", px - 6, py - 10);
    }

    if (player.negotiating) {
      const barW = 120, barH = 10;
      const bx = px + pw / 2 - barW / 2;
      const by = py - 24;
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(bx, by, barW, barH);
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.fillRect(bx + 2, by + 2, (barW - 4) * clamp(player.negoProgress / 100, 0, 1), barH - 4);
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, sans-serif";
      ctx.fillText("交渉中…（離れると中断）", bx, by - 6);
    }
  }

  function drawEnemies(pal) {
    for (const e of enemies) {
      let c = "#ef4444"; // hostile
      if (e.stance === "neutral" || !e.hostile) c = "#eab308";
      if (e.stance === "allied") c = "#22c55e";
      if (e.type === "drone") c = "#a78bfa";

      ctx.fillStyle = c;
      ctx.fillRect(e.x, e.y, e.w, e.h);

      // visor
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.fillRect(e.x + 5, e.y + 8, e.w - 10, 8);

      // label near if close
      const dx = Math.abs((e.x+e.w/2) - (player.x+player.w/2));
      const dy = Math.abs((e.y+e.h/2) - (player.y+player.h/2));
      if (dx < 140 && dy < 90) {
        ctx.fillStyle = "rgba(255,255,255,0.85)";
        const tag = e.negotiable ? "交渉可" : "交渉不可";
        ctx.fillText(`${nameOfEnemy(e.type)}（${tag}）`, e.x - 6, e.y - 8);
      }
    }
  }

  function nameOfEnemy(type) {
    const map = {
      militia: "民兵",
      caravan: "輸送隊",
      poacher: "密猟者",
      guerrilla: "ゲリラ",
      riot: "群衆",
      security: "治安部隊",
      drone: "監視ドローン",
    };
    return map[type] || type;
  }

  function drawHUD(pal) {
    // top bar
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.fillRect(0,0,W,54);

    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.font = "16px system-ui, -apple-system, Segoe UI, sans-serif";
    ctx.fillText(game.stage.title, 12, 22);

    // Trust bar
    const trustW = 220, trustH = 12;
    const tx = 12, ty = 32;
    ctx.fillStyle = "rgba(255,255,255,0.18)";
    ctx.fillRect(tx, ty, trustW, trustH);
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.fillRect(tx, ty, trustW * (player.trust/100), trustH);
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.fillText(`信頼`, tx + trustW + 10, ty + 11);

    // HP & Alert
    ctx.fillText(`HP: ${player.hp}`, 360, 42);
    ctx.fillText(`警戒: ${game.alert}`, 430, 42);

    // message
    if (game.messageT > 0 && game.message) {
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.fillRect(0, H-64, W, 64);
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.font = "16px system-ui, -apple-system, Segoe UI, sans-serif";
      ctx.fillText(game.message, 14, H-28);
    }

    // stage notes mini (right side)
    if (game.stage.npcNotes && game.stage.npcNotes.length) {
      ctx.font = "12px system-ui, -apple-system, Segoe UI, sans-serif";
      ctx.fillStyle = "rgba(255,255,255,0.65)";
      const baseX = W - 360, baseY = 18;
      ctx.fillText("現場メモ：", baseX, baseY);
      for (let i=0;i<Math.min(2, game.stage.npcNotes.length); i++) {
        ctx.fillText("・" + game.stage.npcNotes[i], baseX, baseY + 16*(i+1));
      }
    }
  }

  function drawIntroOverlay(pal) {
    ctx.fillStyle = "rgba(0,0,0,0.65)";
    ctx.fillRect(0,0,W,H);

    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.font = "24px system-ui, -apple-system, Segoe UI, sans-serif";
    ctx.fillText(game.stage.title, 40, 70);

    ctx.font = "16px system-ui, -apple-system, Segoe UI, sans-serif";
    const lines = game.stage.intro || ["..."];
    const shown = lines.slice(0, game.introLine + 1);
    let y = 120;
    for (const ln of shown) {
      wrapText(ln, 40, y, W-80, 22);
      y += 30;
    }

    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.font = "14px system-ui, -apple-system, Segoe UI, sans-serif";
    ctx.fillText("Enter / Space / E で進む", 40, H - 40);
  }

  function drawGameoverOverlay(pal) {
    ctx.fillStyle = "rgba(0,0,0,0.72)";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.font = "28px system-ui, -apple-system, Segoe UI, sans-serif";
    ctx.fillText("任務失敗", 40, 80);

    ctx.font = "16px system-ui, -apple-system, Segoe UI, sans-serif";
    wrapText(game.message || "Rで再開", 40, 130, W-80, 22);

    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.fillText("Rでリトライ", 40, H - 40);
  }

  function wrapText(text, x, y, maxWidth, lineHeight) {
    const words = text.split("");
    let line = "";
    for (let i=0;i<words.length;i++) {
      const test = line + words[i];
      const w = ctx.measureText(test).width;
      if (w > maxWidth && line.length > 0) {
        ctx.fillText(line, x, y);
        line = words[i];
        y += lineHeight;
      } else {
        line = test;
      }
    }
    if (line) ctx.fillText(line, x, y);
  }

  // =========================================================
  // Main loop
  // =========================================================
  function tick() {
    update();
    draw();
    justPressed.clear(); // Clear at end of frame so input is available during update
    requestAnimationFrame(tick);
  }
  tick();

  // quick reset / debug
  window.addEventListener("keydown", (e) => {
    if ((e.key === "r" || e.key === "R") && game.state === "play") {
      // allow manual restart too
      loadStage(game.stageIndex);
    }
  });

})();
</script>
</body>
</html>
